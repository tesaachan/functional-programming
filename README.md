# Functional Programming in Scala
EPFL on Coursera. 
*Functional programming principles* (progfun1). 
*Functional program design* (progfun2). 
Lectures are collected and stored by weeks (lectures). 
Assignments' tasks are collected and stored (labs_md)

| Week | Topic                      | Description             | Assignment
| :--  | :--                        | :--                     | :--  
| 1    | [Functions and Evaluation](lectures/progfun1-week1.pdf)     | Programming Paradigms<br/>Elements of Programming<br/>Evaluation Strategies and Termination<br/>Square roots with Newton's method<br/>Blocks and Lexical Scope<br/>Tail recursion | ***Recursion***<br/>[task](labs_md/1_recfun.md)<br/>[code](progfun1/week1/recfun) |
| 2    | Higher-Order Functions     | Higher-order functions<br/>Currying<br/>Functions and data<br/>More Fun With Rationals<br/>Evaluations and Operators | ***Purely Functional Sets***<br/>[task](labs_md/2_funsets.md)<br/>[code](progfun1/week2/funsets)
| 3    | Data and Abstraction       | Class hierarchies<br/>How classes are organized<br/>Polymorphism<br/>Objects Everywhere<br/>Functions as Objects | ***Object-Oriented Sets***<br/>[task](labs_md/3_objsets.md)<br/>[code](progfun1/week3/objsets) |
| 4    | Types and Pattern Matching | Decomposition<br/>Pattern Matching<br/>Lists<br/>Enums<br/>Subtyping and Generics<br/>Variance | ***Huffman***<br/>[task](labs_md/4_patmat.md)<br/>[code](progfun1/week4/patmat/) |
| 5    | Lists                      | A Closer Look at Lists<br/>Tuples and Generic Methods<br/>Higher-order list functions<br/>Reduction of Lists<br/>Reasoning about lists | - |
| 6    | Collections                | Other Collections<br/>Combinatorial Search and For-Expressions<br/>Combinatorial Search Example<br/>Maps | ***Anagram***<br/>[task](labs_md/5_forcomp.md)<br/>[code](progfun1/week6/forcomp/) |
| 7    | For Expressions and Monads | Queries with For<br/>Translation of For<br/>Functional Random Generators<br/>Monads<br/>Exceptional Monads | ***QuickCheck***<br/>[task](labs_md/6_quickcheck.md)<br/>[code](progfun2/week1/quickcheck) |
| 8    | Lazy Evaluation            | Structural Induction on Trees<br/>Lazy Lists<br/>Lazy Evaluation<br/>Computing with Infinite Sequences<br/>The Water Pouring Problem | ***Bloxorz***<br/>[task](labs_md/7_bloxorz.md)<br/>[code](progfun2/week2/streams) |
| 9    | Type-Directed Programming  | Contextual abstractions<br/>Using clauses and given instances<br/>Type classes<br/>Abstract algebra and type classes<br/>Context passing<br/>Implicit function types | ***Codecs***<br/>[task](labs_md/8_codecs.md)<br/>[code](progfun2/week3/codecs)|
| 11   | Functions and State        | Functions and State<br/>Identity and Change<br/>Loops<br/>Discrete Event Simulation | - |
| 12   | Timely Effects             | Imperative Event Handling: The Observer Pattern<br/>Functional Reactive Programming<br/>A Simple FRP Implementation |

