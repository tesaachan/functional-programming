# Functional Programming in Scala
EPFL on Coursera. 
*Functional programming principles* (progfun1). 
*Functional program design* (progfun2). 
Lectures are collected and stored by weeks (lectures). 
Assignments' tasks are collected and stored (labs_md)

| Week | Topic                      | Content             | Assignment
| :--  | :--                        | :--                     | :--  
| 1    | [Functions and Evaluation](progfun1/week1)     | Programming Paradigms<br/>Elements of Programming<br/>Evaluation Strategies and Termination<br/>Square roots with Newton's method<br/>Blocks and Lexical Scope<br/>Tail recursion | ***Recursion***<br/>[task](labs_md/1_recfun.md)<br/>[code](progfun1/week1/recfun) |
| 2    | [Higher-Order Functions](progfun1/week2)     | Higher-order functions<br/>Currying<br/>Functions and data<br/>More Fun With Rationals<br/>Evaluations and Operators | ***Purely Functional Sets***<br/>[task](labs_md/2_funsets.md)<br/>[code](progfun1/week2/funsets)
| 3    | [Data and Abstraction](progfun1/week3)       | Class hierarchies<br/>How classes are organized<br/>Polymorphism<br/>Objects Everywhere<br/>Functions as Objects | ***Object-Oriented Sets***<br/>[task](labs_md/3_objsets.md)<br/>[code](progfun1/week3/objsets) |
| 4    | [Types and Pattern Matching](progfun1/week4) | Decomposition<br/>Pattern Matching<br/>Lists<br/>Enums<br/>Subtyping and Generics<br/>Variance | ***Huffman***<br/>[task](labs_md/4_patmat.md)<br/>[code](progfun1/week4/patmat/) |
| 5    | [Lists](progfun1/week5)                      | A Closer Look at Lists<br/>Tuples and Generic Methods<br/>Higher-order list functions<br/>Reduction of Lists<br/>Reasoning about lists | - |
| 6    | [Collections](progfun1/week6)                | Other Collections<br/>Combinatorial Search and For-Expressions<br/>Combinatorial Search Example<br/>Maps | ***Anagram***<br/>[task](labs_md/5_forcomp.md)<br/>[code](progfun1/week6/forcomp/) |
| 7    | [For Expressions and Monads](progfun2/week1) | Queries with For<br/>Translation of For<br/>Functional Random Generators<br/>Monads<br/>Exceptional Monads | ***QuickCheck***<br/>[task](labs_md/6_quickcheck.md)<br/>[code](progfun2/week1/quickcheck) |
| 8    | [Lazy Evaluation](progfun2/week2)            | Structural Induction on Trees<br/>Lazy Lists<br/>Lazy Evaluation<br/>Computing with Infinite Sequences<br/>The Water Pouring Problem | ***Bloxorz***<br/>[task](labs_md/7_bloxorz.md)<br/>[code](progfun2/week2/streams) |
| 9    | [Type-Directed Programming](progfun2/week3)  | Contextual abstractions<br/>Using clauses and given instances<br/>Type classes<br/>Abstract algebra and type classes<br/>Context passing<br/>Implicit function types | ***Codecs***<br/>[task](labs_md/8_codecs.md)<br/>[code](progfun2/week3/codecs)|
| 10   | [Functions and State](progfun2/week4)        | Functions and State<br/>Identity and Change<br/>Loops<br/>Discrete Event Simulation | - |
| 11   | [Timely Effects](progfun2/week5)             | Imperative Event Handling: The Observer Pattern<br/>Functional Reactive Programming<br/>A Simple FRP Implementation | ***Calculator***<br/>task<br/>[code](progfun2/week5/calculator)|

